:sectnums:
:sectnumlevels: 3
:imagesdir: ../images 
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

= Building Python Containers

There are two several ways in which one can build a container. 

One method that is very easy is to start a container, make changes to the container while it is running, and do a docker commit.  This works, but should you find an error or vulnerability in the base container layers, these are difficult to fix.

tip: Container guilds, such as "docker build" strategies provide an "infrastructure as code" replicable solution

== Dockerfile or Containerfile Use

You may have heard the term "Dockerfile" used as the descriptor of a container build. "Containerfile" is an equivalent term, meaning exactly the same thing. The terminology change comes from a shift of focus from a company name being used, to one of a more generic "open standard" terminology. There are possibly some open source political histories at play. I'll use them interchangeably in order to add to the confusion! In fact, you can name this file anything you want.

=== Building and running a Python Flask Application Container

We can build flask app containers in several ways. They can be simple flask "debug mode" implementations. Production grade Flask, Django, Pyramid, etc.  applications require a WSGI gateway. Gunicorn is currently popular for such applications.

Container builds are commonly done from a file known as a "Dockerfile", or "Containerfile" that describe how containers are built in layers. Layers are added to immutable under layers in order to provide the "diffs" or differential changes to the image. This is patterned after the good old "tar" (Tape ARchive) format from early long term storage formats in the computer industry.

==== Build from a generic image from a "Community Official" image

The following is the "Dockerfile". In this case, we are choosing to call it the "Containerfile.flask".  The `-f`
parameter will ensure that the Docker Build command finds it definition file.

While this is a Flask "hello world", we will not use the default port of 5000. We will use 8080 as that is a good port to use in OpenShift, but you can use whatever you want with a little more effort.


[source,bash]
cat > Dockerfile.hello-world <<UNTILHERE
FROM python:3.9-buster
MAINTAINER YourNameHere imnota@yahoo.com
COPY ./requirements.txt ./helloworld.py .
WORKDIR /
RUN pip install -r requirements.txt
EXPOSE 8080
CMD ["python", "./helloworld.py"]
UNTILHERE

So what is happening in the Dockerfile?

FROM represents our source image. We have the repo: ```python```, and the tag ```3.9-buster```

This repo and tag refer to the "Official Community Maintained Container for Python". Will you use that container as a base? Great question. Later we will show a more secure base image.

The lines below populate the requirements.txt so that pip can do it's job. IRL (In Real Life) you would probably want to use an on-site or curated pip repository. Of course, you would also care about specifying versions of the installed modules. Today, flask is at 1.1.2.

[source,bash]
cat > requirements.txt <<UNTILHERE
flask==1.1.2
flask_restful==0.3.8
UNTILHERE


The lines below represent the application itself. Put this in a file called helloworld.py


[source,python]
--
cat > helloworld.py <<UNTILHERE
from flask import Flask, request
from flask_restful import Resource, Api

application = Flask(__name__)
api = Api(application)

class Greeting (Resource):
    def get(self):
        return 'Hello World!'

api.add_resource(Greeting, '/') # Route_1

if __name__ == '__main__':
    application.run('0.0.0.0','8080')
UNTILHERE
--


Finally, let's run the command that puts it all together:

[source,bash]
$ podman build -f Dockerfile.hello-world -t hello-world-py

Here is what happened on my machine:

```
STEP 1: FROM python:3.9-buster
STEP 2: MAINTAINER YourNameHere imnota@yahoo.com
--> Using cache 7f2392e40e32b4155cf7dd1aeeb951950f0bd44ba53b3daf4789fd051336b750
STEP 3: COPY ./requirements.txt ./helloworld.py .
9b926f09f16ebb4d5037f903aead98e91f19bc6c6e57627a396bb4bec8b2bcd4
STEP 4: WORKDIR /
db42f3cfc1175087e2eac9ae0c57ab275b2481c45b345b06dc9805b58da52de0
STEP 5: RUN pip install -r requirements.txt
Collecting flask==1.1.2
  Downloading Flask-1.1.2-py2.py3-none-any.whl (94 kB)
     |████████████████████████████████| 94 kB 1.1 MB/s 
Collecting flask_restful==0.3.8
  Downloading Flask_RESTful-0.3.8-py2.py3-none-any.whl (25 kB)
Collecting aniso8601>=0.82
  Downloading aniso8601-8.1.0-py2.py3-none-any.whl (44 kB)
     |████████████████████████████████| 44 kB 854 kB/s 
Collecting click>=5.1
  Downloading click-7.1.2-py2.py3-none-any.whl (82 kB)
     |████████████████████████████████| 82 kB 357 kB/s 
Collecting itsdangerous>=0.24
  Downloading itsdangerous-1.1.0-py2.py3-none-any.whl (16 kB)
Collecting Jinja2>=2.10.1
  Downloading Jinja2-2.11.2-py2.py3-none-any.whl (125 kB)
     |████████████████████████████████| 125 kB 1.9 MB/s 
Collecting MarkupSafe>=0.23
  Downloading MarkupSafe-1.1.1.tar.gz (19 kB)
Collecting pytz
  Downloading pytz-2020.4-py2.py3-none-any.whl (509 kB)
     |████████████████████████████████| 509 kB 1.7 MB/s 
Collecting six>=1.3.0
  Downloading six-1.15.0-py2.py3-none-any.whl (10 kB)
Collecting Werkzeug>=0.15
  Downloading Werkzeug-1.0.1-py2.py3-none-any.whl (298 kB)
     |████████████████████████████████| 298 kB 1.6 MB/s 
Building wheels for collected packages: MarkupSafe
  Building wheel for MarkupSafe (setup.py) ... done
  Created wheel for MarkupSafe: filename=MarkupSafe-1.1.1-cp39-cp39-linux_x86_64.whl size=32228 sha256=f399be1301220bdd505a0f867fbb171ddc3ed766384ffc7d93a8d75e4f2bb758
  Stored in directory: /root/.cache/pip/wheels/e0/19/6f/6ba857621f50dc08e084312746ed3ebc14211ba30037d5e44e
Successfully built MarkupSafe
Installing collected packages: MarkupSafe, Werkzeug, Jinja2, itsdangerous, click, six, pytz, flask, aniso8601, flask-restful
Successfully installed Jinja2-2.11.2 MarkupSafe-1.1.1 Werkzeug-1.0.1 aniso8601-8.1.0 click-7.1.2 flask-1.1.2 flask-restful-0.3.8 itsdangerous-1.1.0 pytz-2020.4 six-1.15.0
dd4484dbee5ded728db01cfae93af44ce837cb75a3fd307a2bb858c97dacc646
STEP 6: EXPOSE 8080
00d26007838a5a54274619f5032421f9f0db2574ebfcf6da26954b28dc9dbe57
STEP 7: CMD ["python", "./helloworld.py"]
STEP 8: COMMIT hello-world-py
1f6870effc8bb9b5a0e609ef42a6f3d97258e9a34b1ad2460a1458bd0b95729c
1f6870effc8bb9b5a0e609ef42a6f3d97258e9a34b1ad2460a1458bd0b95729c

[student@podman ~]$ 
```
[source,bash]
podman images

Yields
```
REPOSITORY                 TAG          IMAGE ID       CREATED        SIZE
localhost/hello-world-py   latest       cc087b7fba56   33 hours ago   919 MB
docker.io/library/python   3.9-buster   a879e610c533   2 days ago     908 MB
[student@podman ~]$ 

```
Very pretty! But will it run??

[source,bash]
podman run --rm -p 8080:8080 localhost/hello-world-py

The --rm will remove the container once it is stopped. The -p maps external host to internal pod ip addresses.
We will be running this container in the foreground, but *not* using -it for interactive terminal.

```
[student@podman ~]$ podman run --rm -p 8080:8080  localhost/hello-world-py 
 * Serving Flask app "helloworld" (lazy loading)
 * Environment: production
   WARNING: This is a development server. Do not use it in a production deployment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on http://0.0.0.0:8080/ (Press CTRL+C to quit)
````

curl or browser access port 8080 on your machine to prove out the implementation.

[source,bash]
podman run --rm -it -p 8080:8080  localhost/hello-world-py /bin/bash

Will land you in the container, and apparent root

```
root@f283db2a2d71:/# ls
bin  boot  dev	etc  helloworld.py  home  lib  lib64  media  mnt  opt  proc  requirements.txt  root  run  sbin	srv  sys  tmp  usr  var
root@f283db2a2d71:/# python --version
Python 3.9.1
root@f283db2a2d71:/# which python
/usr/local/bin/python
root@f283db2a2d71:/# 
```

NOTE: my application landed in root, this could be changed by putting it into a working directory in the `Dockerfile.flask` build file






==== UBI: Build from a generic image

Let's start with a build from an "Official Community Dockerhub" base image.

[source, config]
FROM registry.access.redhat.com/ubi8/ubi
RUN yum install -y python3 ; yum clean all
COPY ./requrements.txt /app/requirements.txt
WORKDIR /app
RUN python3 -m pip install -r requirements.txt
COPY ./src /app/src
EXPOSE 8080
ENTRYPOINT ["python3"]
CMD ["src/main.py"]

Here is our slightly different application:

[source,python]
--
from flask import Flask, request
from flask_restful import Resource, Api

application = Flask(__name__)
api = Api(app)

class Greeting (Resource):
    def get(self):
        return 'Hello World!'

api.add_resource(Greeting, '/') # Route_1

if __name__ == '__main__':
    application.run('0.0.0.0','8080')
--
